#include <iostream>#include <limits>//typedef struct {                               //В начале .bmp лежит список параметров, описание изображения//    unsigned short int bfType;    //тип файла в виде 16-ричного числа: 0x42d42 | 0x4349 | 0x5450//    int bfSize;                 //размер файла//    int bfReserved;             // 0//    int bfOffBits;              //смещение до поля данных, обычно 14(первые три параметра)+biSize (всего 54)//    int biSize;                 //размер структуры(списка параметров) в байтах//    int biWidth;                //ширина в точках 19-й байт структуры//    int biHeight;               //высота в точках//    unsigned short int biPlanes;  //всегда должно быть 1//    unsigned short int biBitCount;//количество бит на пиксель 0,1,4,8,16,24(как необходимо в задании) или 32//    int biCompression;          //BI_RGB, BI_RLE8, BI_RLE4, BI_BITFIELDS, BI_JPEG, BI_PNG//    int biSizeImage;            //количество байт в поле данных, обычно ставится 0//    int biXPelsPerMeter;        //горизонтальное разрешение точек на ДЮЙМ//    int biYPelsPerMeter;        //вертикальное разрешение точек на ДЮЙМ//    int biClrUsed;              //Количество используемых цветов//    int biClrImportant;         //количество существенных цветов, 0//} BMPHeader;int checkCPU()                  //Проверка порядка хранения данных{    union {        int a;        char b;    }c;    c.a = 1;    return (c.b == 1);          //сетевой - false, интеловский порядок байт - true}void input(int &inp)            //Функция ввода с проверкой значений на int {    std::cin >> inp;    bool flag = 0;    while (std::cin.fail())    {        std::cin.clear();//очистка флага        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');//удаление данных        std::cout << "\nвведите заново: ";        std::cin >> inp;    }}const char* RGB24_to_YUV420(const char* sourse, int &width, int &height){    const char* destination = "YUV_image.yuv";    width = height = -1;    int i, j, cpu = checkCPU();                    //проверка ЦП, 2 счётчика для ширины, высоты    unsigned char r, g, b;                              FILE *fp_s = fopen(sourse, "rb+");    if (!fp_s) { "\nФайл не существует или повреждён\n"; fclose(fp_s); return NULL; }            fseek(fp_s, 0, SEEK_END);    int filesize = ftell(fp_s);    fseek(fp_s, 18, SEEK_SET);//Ставим указатель на 18 байт, после которого лежит ширина картинки    i = fread(&width, 1, sizeof(int), fp_s);//считываем ширину и длину    i = fread(&height, 1, sizeof(int), fp_s);    fseek(fp_s, 54, SEEK_SET);//сместили указатель на длину структуры с описанием файла            std::cout << "Картинка: высота = " << height << ", ширина = " << width << std::endl;    FILE* fp_d = fopen(destination, "wb+");    int rgb_row_width = (3 * width + 3) & (-4);//так как в bmp каждая строка достраивается до кратной 4, вычисляем актуальную длину строки в байтах                                         // &(-4) - побитовое И, по сути - остаток от деления на 4    //выделить память и прочитать изображение RGB24    unsigned char *b_s = (unsigned char*)malloc(sizeof(char) * rgb_row_width * height);//size    unsigned char *b_d_y = (unsigned char*)malloc(sizeof(char) * width * height),  * h_p_y = b_d_y + width * height-1;    unsigned char *b_d_u = (unsigned char*)malloc(sizeof(char) * width * height/4), * h_p_u = b_d_u + width * height/4-1;    unsigned char *b_d_v = (unsigned char*)malloc(sizeof(char) * width * height/4), * h_p_v = b_d_v + width * height / 4 - 1;    //так как .bmp файл расположен в памяти задом наперёд, нужно ввести дополнительно 3 указателя: h_p_y, h_p_u, h_p_v    i = fread(b_s, 1, rgb_row_width * height, fp_s);    std::cout <<i<<" байт прочитано\n";    std::string cp = cpu == 1 ? "интеловский" : "сетевой";    std::cout << "CPU имеет " << cp << " порядок байт. " << "Начинаю обработку данных";    //преобразование данных        for (i = 0;i < height;i++) {        for (j = 0; j < width;j++) {            if (cpu) {// интеловский порядок хранения байт - BGR BGR...                r = b_s[3* (i*width +j) + 2];                g = b_s[3 * (i * width + j) + 1];                b = b_s[3 * (i * width + j) + 0];            }            else {//сетевой порядок хранения байт - RGB RGB...                r = b_s[3 * (i * width + j) + 0];                g = b_s[3 * (i * width + j) + 1];                b = b_s[3 * (i * width + j) + 2];            }            *h_p_y-- = (unsigned char)((66* r + 129 * g +25 *b + 128)>>8)+16;// >>8 = /256 (unsigned char)(0.299 * r + 0.587 * g + 0.114 * b);            //теперь для каждых 4Y компонент взять по одной U и V            if (i % 2 == 0 && j % 2 == 0)            {                *h_p_u-- = (unsigned char)((-38 * r - 74 * g + 112 * b + 128) >> 8) + 128; // (unsigned char)(-0.147 * r - 0.289 * g + 0.463 * b);                *h_p_v-- = (unsigned char)((112 * r - 94 * g - 18 * b + 128) >> 8) + 128; // (unsigned char)(0.615 * r - 0.515 * g - 0.100 * b);            }                    }    }    std::cout << "\nКонверсия Завершена\n";    i = fwrite(b_d_y, 1, width * height, fp_d);    std::cout << i << "байт записаны (Y)\n";    i = fwrite(b_d_u, 1, width * height/4, fp_d);    std::cout << i << "байт записаны (U)\n";    i = fwrite(b_d_v, 1, width * height/4, fp_d);    std::cout << i << "бит записаны (V)\n";    free(b_s);    free(b_d_y);    free(b_d_u);    free(b_d_v);    fclose(fp_s);    fclose(fp_d);    std::cout << "Результат конверсии в файле " << destination << "\n";    return "YUV_image.yuv";}void make_video_with_image(const char* video, const char* bmp){    int image_width, image_height;    const char *image = RGB24_to_YUV420(bmp, image_width, image_height);    if (image == NULL) { std::cout << "\nОшибка чтения или конверсии картинки\n"; return; }    int video_width, video_height;//считываем статично размер файла, у моего тестового файла .bmp - 246Х268    std::cout << "\nвведите ширину видео: ";    input(video_width);    std::cout << "\nвведите высоту видео: ";    input(video_height);    std::cout << "Видео: высота =  " << video_height << ", ширина = " << video_width << std::endl;    FILE* fp_i = fopen(image, "rb+");    FILE* fp_v = fopen(video, "rb+");    FILE* fp_v_n = fopen("new.yuv", "wb+");    fseek(fp_v, 0, SEEK_END);    int video_size = ftell(fp_v)/2;    fseek(fp_v, 0, SEEK_SET);       int frame_size = video_width * video_height * 3 / 2; //h*w для y 2*(h*v/4) для u,v, в сумме 3/2 или 1.5 общего объёма    int frame_pixels_size = video_width * video_height;    int image_pixels_size = image_width * image_height;    int image_size = image_width * image_height * 3 / 2;    unsigned char* video_buf = (unsigned char*)malloc(sizeof(char) * video_size);    unsigned char* image_buf = (unsigned char*)malloc(sizeof(char) * image_size);        int i, j, fr_num;    //    i = fread(video_buf, 1, video_size , fp_v);    std::cout << i << " байт видео прочитано\n";    i = fread(image_buf, 1, image_width * image_height * 3 / 2, fp_i);    std::cout << i << " байт картинки прочитано\n";    int num_frames = int(video_size / (video_width * video_height * 3 / 2));//количество кадров    std::cout << num_frames <<"кадров\n";    unsigned char * y = video_buf;    unsigned char * u = y + frame_pixels_size;    unsigned char * v = u + frame_pixels_size/4;    for (fr_num = 0; fr_num < num_frames; fr_num++)    {        for (j = 0;j < image_height; j++)        {            for (i = 0; i < image_width; i++)            {                *(y + i + j * video_width + fr_num * frame_size) = *(image_buf + i + j * image_width);//сместиться на fr_num кадров и положить в i позицию в j строке такое же значение картинки                if ((i + j * video_width) %4 == 0 && (i + j * image_width) % 4 == 0)                {                    *(u + (i+ j * video_width)/4 + fr_num * frame_size ) = *(image_buf + image_pixels_size + (i + j * image_width) / 4);                    //сместиться на fr_num кадров и положить в i позицию в j строке такое же значение картинки                    *(v + (i+ j * video_width)/4 + fr_num * frame_size ) = *(image_buf + image_pixels_size + image_pixels_size / 4 + (i + j * image_width) / 4);                    //сместиться на fr_num кадров и положить в i позицию в j строке такое же значение картинки                    //для u, v участки памяти меньше в 4 раза, значит и шаг в 4 раза меньше                }            }        }        std::cout << fr_num << "кадр обработан\n";    }    std::cout << "видео обработано\n";    i = fwrite(video_buf, 1, video_size, fp_v_n);    std::cout << i << "байт записаны \n";    free(video_buf);    free(image_buf);    fclose(fp_i);    fclose(fp_v);    fclose(fp_v_n);    std::cout << "всё готово, результат в файле "<< "new.yuv" <<"\n";}int main(){    make_video_with_image("out.yuv", "diamond.bmp");            }